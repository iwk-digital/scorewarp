<html>

<head>
  <meta charset="utf-8">
  <script src="http://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js" defer></script>
  <script>
    //
    //
    let fileName = "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op119_BreitkopfHaertel/master/Beethoven_Op119_Nr01-Breitkopf.mei";

    document.addEventListener("DOMContentLoaded", (event) => {
      Module.onRuntimeInitialized = async _ => {
        let tk = new verovio.toolkit();
        console.log("Verovio " + tk.getVersion() + ' loaded.');

        fetch(fileName)
          .then((response) => response.text())
          .then((meiXML) => {
            tk.setOptions({
              scale: 30,
              breaks: "none",
              header: "none",
              footer: "none"
            });
            let svg = tk.renderData(meiXML, {});
            // console.info('Notation SVG: ', svg);
            let notationDiv = document.getElementById("notation");
            notationDiv.innerHTML = svg;
            // let bb = notationDiv.getBoundingClientRect(); // getBBox
            svgObj = document.querySelector('svg');
            let svgWidth = parseFloat(svgObj.getAttribute('width'));
            svgViewBox = svgObj.querySelector('svg[viewBox]').getAttribute('viewBox');
            svgViewBox = svgViewBox.split(' ').map(Number);
            let pageMarginElement = svgObj.querySelector('.page-margin');
            let transformations = pageMarginElement.transform.baseVal;
            console.info('svgObj: ', svgObj);
            console.info('svgObj width: ', svgWidth);
            console.info('svgObj viewBox: ', svgViewBox);
            console.info('svgObj transform: ', pageMarginElement.transform);
            console.info('svgObj transform bsVl: ', transformations.getItem(0));
            let pageMarginX = transformations.getItem(0).matrix.e;
            // let noteHeadUses = svgObj.querySelectorAll('g.notehead use');
            // take first and last noteId to normalize...
            let el1 = document.querySelector(`[*|id="${xmlIds[0]}"] use[x]`);
            console.info('el1: ', el1);
            let firstX = parseFloat(el1.getAttribute('x'));
            firstX = (pageMarginX + firstX) * svgWidth /
              (svgViewBox[2] - svgViewBox[0]);
            console.info('firstNotehead x: ', firstX);
            let el2 = document.querySelector(`[*|id="${xmlIds[xmlIds.length-1]}"] use[x]`);
            console.info('el2: ', el2);
            let lastX = parseFloat(el2.getAttribute('x'));
            lastX = (pageMarginX + lastX) * svgWidth /
              (svgViewBox[2] - svgViewBox[0]);
            console.info('lastNotehead x: ', lastX);
            let scoreTimeDiv = document.getElementById("scoreTime");

            // scoreTime Panel to demonstrate
            let stObj = createScoreTimeSVG(svgWidth, 200);
            addLine(stObj, firstX, firstX, 100, 180, 'blue');
            addLine(stObj, lastX, lastX, 100, 180, 'blue');
            let tmin = onsetTimes[0];
            let tmax = onsetTimes[onsetTimes.length - 1];
            noteXs = [];
            noteSVGXs = [];
            xmlIds.forEach(item => {
              let note = document.querySelector('[*|id="' + item + '"]');
              console.info('note: ', note);
              let noteX = parseFloat(note.querySelector('g.notehead use').getAttribute('x'));
              console.info('noteX: ', noteX);
              noteSVGXs.push(noteX); // pure SVG x values (without page-margin)
              noteX = (noteX + pageMarginX) * svgWidth /
                (svgViewBox[2] - svgViewBox[0]);
              console.info('noteX: ', noteX);
              noteXs.push(noteX);
            });
            onsetTimes.forEach((t, i) => {
              // let screenX = (t - tmin) / (tmax - tmin) * svgWidth + firstX;
              let screenX = (t - tmin) / (tmax - tmin) *
                (lastX - firstX) + firstX;
              addLine(stObj, screenX, screenX, 60, 130, 'purple');
              addLine(stObj, screenX, noteXs[i], 60, 1, 'orange');
            });
            onsetTimes.forEach(item => {
              onsetSVGXs.push((item - tmin) / (tmax - tmin) *
                (noteSVGXs[noteSVGXs.length - 1] - noteSVGXs[0]) + noteSVGXs[0]);
            });

            // add them to the notation svg
            let systemElement = document.querySelector('.system');
            onsetSVGXs.forEach((item, i) => {
              addLine(systemElement, item, item, 0, svgViewBox[3], 'green');
            });


            // scoreTimeDiv.appendChild(createScoreTimeSVG(bb.width, 200));
            const serializer = new XMLSerializer();
            let stSVG = serializer.serializeToString(stObj);
            // console.info('stSVG: ' + stSVG);
            scoreTimeDiv.innerHTML = stSVG;
            console.info('NotationDiv: ', notationDiv);

            let log = document.getElementById('log');
            // console.info('log: ', log);
            document.addEventListener('keyup', logKey);

            elementList = pageMarginElement.querySelectorAll(
              'g.chord, :not(g.chord)>g.note, use[x], rect[x], text[x], polygon, ellipse, circle, path');
            console.info('elementList: ', elementList);
          });
      }
    });

    const onsetTimes = [0.423, 1.043, 2.645, 4.932, 5.12, 6.3, 6.9, 15.3, 49.3, 60.1]; // in seconds
    const xmlIds = [
      'note-0000001757161680', 'note-0000000575445239',
      'note-0000000240809663', 'note-0000000454467549',
      'note-0000000382909269', 'note-0000000100538923',
      'note-0000001709869562', 'note-0000001176381257',
      'note-0000002030166766', 'note-0000001503426145'
    ];
    let noteXs; // x values of notes on screen
    let noteSVGXs; // x values of notes in SVG
    let onsetSVGXs = []; // SVG x values of onset times
    let svgViewBox;
    let svgObj;
    let elementList; // a nodeList of elements that need to be warped

    function logKey(e) {
      // log.textContent += ` ${e.code}`;
      let elementId = xmlIds[6];
      let el = document.querySelector(`[*|id="${elementId}"]`);
      if (e.code == 'KeyR') shiftElement(elementList, el, 50);
      if (e.code == 'KeyL') shiftElement(elementList, el, -50);

      if (e.code == 'KeyW') {
        let warpingFunction = createWarpingFunction(onsetTimes, noteSVGXs, svgViewBox);
        console.info('Do The SVG Warp AGAIN! warpingFunction: ', warpingFunction);
        shiftElement(elementList, null, warpingFunction, true);
      }
    }

    // Returns x value in pure SVG coordinates of SVG element ()
    function getX(el) {
      switch (el.nodeName) {
        case 'polygon':
          return el.points.getItem(0).x;
        case 'path':
          return el.pathSegList.getItem(0).x;
        case 'ellipse' || 'circle':
          return parseFloat(el.getAttribute('cx'));
        case 'rect' || 'use' || 'text':
          return parseFloat(el.getAttribute('x'));
        case 'g': // for .chord, .note
          let className = el.getAttribute('class');
          if (className && (className == 'chord' || className == 'note'))
            return parseFloat(
              el.querySelector('.notehead>use[x]').getAttribute('x'));
          else
            return parseFloat(el.querySelector('use[x]').getAttribute('x'));
      }
    }

    // shift elements horizontally by modifying all x coordinates after element
    // with delta; if withWarp: delta is the warpingFunction for all elements
    function shiftElement(elementList, el, delta, withWarp = false) {
      // let el = document.querySelector(`[*|id="${elementId}"]`);
      // let elX = el.querySelector('use[x]').getAttribute('x');
      let elX = 0;
      if (withWarp)
        console.info('shiftEl with TimeWarp');
      else {
        elX = getX(el);
        console.info('shiftEl ' + delta + '; x: ' + elX + ', el:', el);
      }
      elementList.forEach(item => {
        // console.info('Shifting ', item);
        if (item.nodeName == 'polygon') { // beam,
          // console.info('ShiftElement Polygon points: ', item.points);
          let pointsList = item.points;
          let n = pointsList.numberOfItems;
          for (let m = 0; m < n; m++) {
            var mySVGPoint = svgObj.createSVGPoint();
            let x = pointsList.getItem(m).x;
            if (withWarp) {
              mySVGPoint.x = x + delta[Math.round(x)];
              mySVGPoint.y = pointsList.getItem(m).y;
              pointsList.replaceItem(mySVGPoint, m);
            } else if (x >= elX) {
              mySVGPoint.x = x + delta;
              mySVGPoint.y = pointsList.getItem(m).y;
              pointsList.replaceItem(mySVGPoint, m);
            }
          }
        } else if (item.nodeName == 'path') {
          // console.info('ShiftElement Path: ', item);
          let segments = item.pathSegList;
          let n = segments.numberOfItems;
          for (var i = 0; i < n; i++) {
            var segment = segments.getItem(i);
            if (withWarp) {
              // console.info('Segment ' + segment.pathSegType + ', ', segment);
              segment.x += delta[Math.round(segment.x)];
              if (segment.x1) segment.x1 += delta[Math.round(segment.x1)];
              if (segment.x2) segment.x2 += delta[Math.round(segment.x2)];
            } else {
              if (segment.x >= elX) segment.x += delta;
              if (segment.x1 && segment.x1 >= elX) segment.x1 += delta;
              if (segment.x2 && segment.x2 >= elX) segment.x2 += delta;
            }
          }
        } else if (item.nodeName == 'g') { // note, chord
          let d = 0;
          let x = getX(item);
          if (withWarp) d = delta[Math.round(x)];
          else if (x >= elX) d = delta;
          let transformX = 0;
          let transform = item.transform.baseVal;
          // console.info('Transform: ', transform);
          if (transform && transform.length > 0) { // if transform exists
            let firstTransform = transform.getItem(0);
            transformX = firstTransform.matrix.e;
            transform.getItem(0).setTranslate(transformX + d, 0);
          } else { // create new transform
            var matrix = svgObj.createSVGMatrix();
            matrix.e = transformX + d;
            // console.info('matrix: ', matrix);
            item.transform.baseVal.appendItem(
              svgObj.createSVGTransformFromMatrix(matrix));
          }
          //item.setAttribute('transform', `translate(${transformX + x + d},0`);
          // console.info('transform on ', item);
        } else { // rect, use, text, ellipse, circle
          if (!item.closest('.chord') && !item.closest('.note')) { // not within
            let attribute = 'x';
            if (item.nodeName == 'ellipse' || item.nodeName == 'circle')
              attribute = 'cx';
            let x = parseFloat(item.getAttribute(attribute));
            let d = 0;
            if (withWarp) d = delta[Math.round(x)];
            else if (x >= elX) d = delta;
            item.setAttribute(attribute, x + d);
          }
        }
      });
    }

    function createWarpingFunction(onsetTimes, noteSVGXs, svgViewBox) {
      console.info('onsetTimes, ', onsetTimes);
      console.info('onsetSVGXs, ', onsetSVGXs);
      console.info('noteSVGXs, ', noteSVGXs);
      console.info('noteXs, ', noteXs);
      console.info('svgViewBox, ', svgViewBox);
      let width = svgViewBox[2] - svgViewBox[0];
      console.info('WarpingFunction width: ', width);
      let warpingFunction = [];
      let [j, i0, v1, v2, ip, lastIp] = [0, 0, 0, 0, 0, 0];
      for (let i = 0; i < width; i++) {
        if (noteSVGXs[j] <= i) {
          i0 = i;
          j++;
        }
        if (j <= 0 || j >= width) ip = lastIp;
        else {
          v1 = onsetSVGXs[j - 1] - noteSVGXs[j - 1]; // onset minus note
          v2 = onsetSVGXs[Math.min(j, onsetSVGXs.length - 1)] -
            noteSVGXs[Math.min(j, noteSVGXs.length - 1)];
          ip = lerp(v1, v2, (i - i0) / (noteSVGXs[j] - noteSVGXs[j - 1]));
          if (!ip) ip = lastIp;
        }
        warpingFunction.push(ip);
        lastIp = ip;
        // console.info('i: ', i + ', j:' + j + ', ' + v1 + '/' + v2 + ', ip:' + ip);
        // if (i > 3900) break;
      };
      return warpingFunction;
    }

    function lerp(v0, v1, t) { // linear interpolation; t from 0 to lgt - 1
      return (1 - t) * v0 + t * v1;
    }

    // Create SVG for score time plotting
    function createScoreTimeSVG(width, height, ) {
      const stSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      // stSVG.setAttribute('fill', 'purple');
      stSVG.setAttribute('width', width);
      stSVG.setAttribute('height', height);
      // stSVG.setAttribute('stroke', 'black');
      return stSVG;
    }

    function addLine(node, x1, x2, y1, y2, color = "black") {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('x2', x2);
      line.setAttribute('y1', y1);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke-width', 1);
      line.setAttribute('stroke', color);
      return node.appendChild(line);
    }
  </script>
</head>

<body>
  <h1>Let&rsquo;s do the SVG Warp again!</h1>
  <p id="log"></p>
  <div id="notation"></div>
  <div id="scoreTime"></div>
</body>

</html>
