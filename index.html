<html>

<head>
  <meta charset="utf-8">
  <link rel="icon" href="https://www.mdw.ac.at/favicon.ico">
  <!-- Access-Control-Allow-Origin: https://iwk.mdw.ac.at -->

  <!-- <script src="http://www.verovio.org/javascript/latest/verovio-toolkit-wasm.js" defer></script> -->
  <script src="./verovio-toolkit-wasm.js" defer></script>
  <script>
    //
    //
    // TODO DEBUG: accept user files

    let defaultPiece = 'Beethoven Op119_No1_1';
    let defaultMeiFileName = "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op119_BreitkopfHaertel/master/Beethoven_Op119_Nr01-Breitkopf.mei";
    //
    let meiFileName = defaultMeiFileName;
    // let mapsFileName = "https://iwk.mdw.ac.at/goebl/svgwarp/eval/Beethoven_Op119_1_maps.json";
    let mapsFileName = "./eval/Beethoven_Op119_1_maps.json";

    var demoFiles = {
      "Beethoven Op53_1": {
        "meiFile": "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op53_HenleUrtext/master/Beethoven_Op53_1-HenleUrtext.mei",
        "performances": {
          "53 Pianist 1": "",
          "53 Pianist 2": ""
        }
      },
      "Beethoven Op53_2": {
        "meiFile": "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op53_HenleUrtext/master/Beethoven_Op53_2-HenleUrtext.mei",
        "performances": {
          "P02 Performance A": "./eval/Op53_2_P02-A.boe.mid.maps.json",
          "P02 Performance B": "./eval/Op53_2_P02-B.boe.mid.maps.json",
          "P02 Performance C": "./eval/Op53_2_P02-C.boe.mid.maps.json",
          "P04 Performance A": "./eval/Op53_2_P04-A.boe.mid.maps.json",
          "P04 Performance B": "./eval/Op53_2_P04-B.boe.mid.maps.json",
          "P04 Performance C": "./eval/Op53_2_P04-C.boe.mid.maps.json",
          "P07 Performance A": "./eval/Op53_2_P07-A.boe.mid.maps.json",
          "P07 Performance B": "./eval/Op53_2_P07-B.boe.mid.maps.json",
          "P07 Performance C": "./eval/Op53_2_P07-C.boe.mid.maps.json",
          "P08 Performance A": "./eval/Op53_2_P08-A.boe.mid.maps.json",
          "P08 Performance B": "./eval/Op53_2_P08-B.boe.mid.maps.json",
          "P08 Performance C": "./eval/Op53_2_P08-C.boe.mid.maps.json"
        }
      },
      "Beethoven Op31_No2_2": {
        "meiFile": "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op31_No2_HenleUrtext/master/Beethoven_Op31_No2_2-HenleUrtext.mei",
        "performances": {
          "Op31-No2_2 D1": "./eval/REC041_12-19_1133.boe.mid.maps.expansion-default.json",
          "Op31-No2_2 D2": "./eval/REC042_12-19_1153.boe.mid.maps.expansion-default.json",
          "Op31-No2_2 D3": "./eval/REC043_12-19_1202.boe.mid.maps.expansion-default.json",
          "Op31-No2_2 D4": "./eval/REC044_12-19_1210.boe.mid.maps.expansion-default.json"
        }
      },
      "Beethoven Op119_No1_1": {
        "meiFile": "https://raw.githubusercontent.com/trompamusic-encodings/Beethoven_Op119_BreitkopfHaertel/master/Beethoven_Op119_Nr01-Breitkopf.mei",
        "performances": {
          "119 Pianist 1": "./eval/Beethoven_Op119_1_maps.json",
          "119 Pianist 2": "./eval/Beethoven_Op119_1_maps.json"
        }
      }
    }

    const svgNS = "http://www.w3.org/2000/svg";
    let maps;
    let tk;
    let tkVersion = '';


    document.addEventListener("DOMContentLoaded", (event) => {
      document.getElementById("notation").innerHTML = "<b>Loading Verovio.</b>";
      Module.onRuntimeInitialized = async _ => {
        tk = new verovio.toolkit();
        tkVersion = tk.getVersion();
        console.log("Verovio " + tkVersion + ' loaded.');
        document.querySelector('#copyright').innerHTML +=
          `Gratefully using
            <a href="https://www.verovio.org/">Verovio ${tkVersion}</a>.`;
        loadMEI();
        // update dropdown menues
        document.getElementById("piece").value = defaultPiece;
        let perfSel = document.getElementById("performance");
        perfSel.length = 1;
        for (var y in demoFiles[defaultPiece].performances) {
          perfSel.options[perfSel.options.length] = new Option(y, y);
        }
        // add keyboardListeners and update notation panel
        document.addEventListener('keyup', keyboardListener);
        document.getElementById("notation").innerHTML = `<b>Verovio ${tkVersion} loaded.</b>`;
      }
    });

    let svgText; // raw SVG text of MEI file
    let noteXs; // x values of notes on screen
    let noteSVGXs; // x values of notes in SVG
    let onsetSVGXs = []; // SVG x values of onset times
    let svgWidth;
    let svgHeight;
    let svgViewBox;
    let pgMarginX;
    let svgObj;
    let elementList; // a nodeList of elements that need to be warped
    let fstX;
    let lstX;
    let tmn; // min performance time
    let tmx; // max
    let warped = false;
    var pieceSel;
    var perfSel;

    function keyboardListener(e) {
      if (e.code == 'KeyW') warp(); // warp score to match performed events
      if (e.code == 'KeyA') warpNotes(); // warp score to match performed notes
      if (e.code == "KeyC") loadMEI(); // reload MEI file
      if (e.code == "KeyD" && svgObj) { // create SVG download link
        createSVGDownloadLink();
      }
    }

    function warp() {
      if (!noteSVGXs) return;
      if (!warped) {
        document.getElementById("downloadLink").innerHTML = "";
        let warpFunc = createWarpingFunction(noteSVGXs, svgViewBox);
        console.info('Do The SVG Warp AGAIN! warpFunc: ', warpFunc);
        shiftElements(elementList, warpFunc);
        drawConnectorLines('chords');
        drawTimeAxis(svgObj, true, svgHeight - 20, 'cornflowerblue');
        warped = true;
        // createSVGDownloadLink(new XMLSerializer().serializeToString(svgObj));
      }
    }

    function warpNotes() {
      if (warped) {
        document.getElementById("downloadLink").innerHTML = "";
        adjustIndividualNotes();
        drawConnectorLines('notes');
      }
    }

    let y0basis = 180; // y of time axis
    let y1 = 80; // y of straigth lines
    let y2 = 0; // y of orange connector lines
    let yMx = 200; // mx y of performance panel

    // draw orange lines, to connect to 'score' or to performed 'notes'
    function drawConnectorLines(target = 'score') { // 'chords', 'notes'
      let pt = document.querySelector('.performanceTime');
      if (pt)
        pt.querySelectorAll('line[stroke="orange"]') // remove lines
        .forEach(item => item.remove());
      let j = 0;
      // plot straight lines
      maps.forEach((item, i) => {
        if (i >= getFirstOnsetIdx(maps) && i <= getLastOnsetIdx(maps)) {
          let t = item.obs_mean_onset;
          let screenX = (t - tmn) / (tmx - tmn) * (lstX - fstX) + fstX;
          if (target == 'score')
            addLine(pt, screenX, noteXs[j++], y1, y2, 'orange');
          else
            addLine(pt, screenX, screenX, y1, y2, 'orange');
        }
      });
    }

    // draws orange lines inside SVG (for debugging)
    function drawPerformanceLinesInSvg() {
      let pageMarginElement = document.querySelector('.page-margin');
      onsetSVGXs.forEach(item => {
        addLine(pageMarginElement, item, item, svgViewBox[3], 0, 'red', 20);
      });
    }

    function drawWarpFunction(node, warpFunc) {
      const g = document.createElementNS(svgNS, 'g'); // warp function in notation
      g.setAttribute('class', 'warpFunction');
      node.appendChild(g);
      let mn = Number.MAX_VALUE;
      let mx = 0;
      warpFunc.forEach(item => {
        if (item < mn) mn = item;
        if (item > mx) mx = item;
      });
      console.info('drawWarpFunction: mn/mx: ' + mn + '/' + mx + ', svgH: ' + svgViewBox[3]);
      let scale = svgViewBox[3] / (mx - mn);
      let translate = 1000; // svgViewBox[3] / 2;
      console.info('drawWarpFunction: scale/trnsl: ' + scale + '/' + translate);
      warpFunc.forEach((item, i) => {
        addCircle(g, i, item * scale + translate, 3, 'red');
      });
    }

    function clearAllLines() {
      let pt = document.querySelector('.performanceTime');
      if (pt) pt.querySelectorAll('line').forEach(item => item.remove());
      let pm = document.querySelector('.page-margin');
      console.info('clearAllLines pm: ', pm);
      if (pm) pm.querySelectorAll('line').forEach(item => item.remove());
    }

    function loadMEI(reload = true) {
      warped = false;
      clearAllLines();
      document.getElementById("downloadLink").innerHTML = "";
      document.getElementById("performanceTime").innerHTML = "";
      document.getElementById("notation").innerHTML = "<b>Loading MEI.</b>";
      if (reload) {
        fetch(meiFileName)
          .then((response) => response.text())
          .then((meiXML) => {
            tk.setOptions({
              scale: 30,
              breaks: "none",
              header: "none",
              footer: "none"
            });
            svgText = tk.renderData(meiXML, {});
            loadMEIfinalizing()
          });
      } else {
        loadMEIfinalizing()
      }
    }

    function loadMEIfinalizing() {
      // console.info('Notation SVG: ', svg);
      let notationDiv = document.getElementById("notation");
      notationDiv.innerHTML = "<p><b>" + pieceSel.value + "</b></p>";
      notationDiv.innerHTML += svgText;
      console.info('NotationDiv: ', notationDiv);

      calculateScoreCoordinates();

      // list all warpable elements of score
      elementList = svgObj.querySelector('.page-margin').querySelectorAll(
        'g.note, g.arpeg, :not(g.notehead):not(g.arpeg)>use[x], rect[x], text[x], polygon, ellipse, circle, path');
      // 'g.chord, :not(g.chord)>g.note, use[x], rect[x], text[x], polygon,
      // ellipse, circle, path');
      console.info('elementList: ', elementList);

      if (pieceSel && pieceSel.value && perfSel && perfSel.value &&
        demoFiles[pieceSel.value].performances[perfSel.value]) {
        updateMapsFile(demoFiles[pieceSel.value].performances[perfSel.value]);
      }
      // createSVGDownloadLink(svgText);
    }

    function calculateScoreCoordinates() {
      svgObj = document.querySelector('svg');
      svgWidth = parseFloat(svgObj.getAttribute('width'));
      svgHeight = parseFloat(svgObj.getAttribute('height'));
      svgViewBox = svgObj.querySelector('svg[viewBox]').getAttribute('viewBox');
      svgViewBox = svgViewBox.split(' ').map(Number);
      let pageMarginElement = svgObj.querySelector('.page-margin');
      let transformations = pageMarginElement.transform.baseVal;
      console.info('svgObj: ', svgObj);
      console.info('svgObj width: ', svgWidth);
      console.info('svgObj viewBox: ', svgViewBox);
      console.info('svgObj transform: ', pageMarginElement.transform);
      console.info('svgObj transform bsVl: ', transformations.getItem(0));
      pgMarginX = transformations.getItem(0).matrix.e;
    }

    function loadPerformanceTiming(maps) {
      // performanceTime Panel to demonstrate
      document.getElementById("downloadLink").innerHTML = "";
      let ptObj = createScoreTimeSVG(svgWidth, yMx);
      ptObj.setAttribute('class', 'performanceTime')
      tmn = maps[getFirstOnsetIdx(maps)].obs_mean_onset;
      // let tmx = maps[getLastOnsetIdx(maps)].obs_mean_onset;
      tmx = maps[getLastOnsetIdx(maps)].obs_mean_onset;

      // take first and last noteId to normalize...
      let id1 = maps[getFirstOnsetIdx(maps)].xml_id[0];
      let el1 = document.querySelector(`[*|id="${id1}"] use[x]`);
      console.info('el1: ', el1);
      fstX = svg2screen(parseFloat(el1.getAttribute('x')));
      console.info('firstNotehead x: ', fstX);
      // let id2 = maps[getLastOnsetIdx(maps)].xml_id[0];
      let id2 = maps[getLastOnsetIdx(maps)].xml_id[0];
      let el2 = document.querySelector(`[*|id="${id2}"] use[x]`);
      console.info('el2: ', el2);
      lstX = svg2screen(parseFloat(el2.getAttribute('x')));
      console.info('lastNotehead x: ', lstX);

      addLine(ptObj, fstX, fstX, y0basis, yMx, 'blue'); // first line
      addLine(ptObj, lstX, lstX, y0basis, yMx, 'blue'); // last line

      // calculate score note coordinates
      noteXs = [];
      noteSVGXs = [];
      maps.forEach((item, i) => {
        if (i >= getFirstOnsetIdx(maps) && i <= getLastOnsetIdx(maps)) {
          let note = document.querySelector('[*|id="' + item.xml_id[0] + '"]');
          if (note) {
            let use = note.querySelector('g.notehead use');
            let noteX = parseFloat(use.getAttribute('x'));
            // console.info(i + '; noteSVGX: ', noteX + ', note: ', note);
            noteSVGXs.push(noteX); // pure SVG x values (without page-margin)
            noteXs.push(svg2screen(noteX));
          } else {
            console.info(i + '; note: NOT FOUND');
          }
        }
      });

      onsetSVGXs = [];
      // calculate noteSVGs and plot onset info to ptObj
      maps.forEach((item, i) => {
        if (i >= getFirstOnsetIdx(maps) && i <= getLastOnsetIdx(maps)) {
          // let screenX = (t - tmn) / (tmx - tmn) * svgWidth + fstX;
          let t = item.obs_mean_onset;
          let screenX = time2screen(t);
          addLine(ptObj, screenX, screenX, 80, 180, 'purple');
          // save onset time data in SVG coordinates
          onsetSVGXs.push(time2svg(t));
        }
      });
      console.info('loadPerformanceTiming: timing mn/mx ' + tmn + '/' + tmx);
      console.info('loadPerformanceTiming: onsetSVGXs', onsetSVGXs);
      console.info('loadPerformanceTiming: noteSVGXs', noteSVGXs);
      console.info('loadPerformanceTiming: noteXs', noteXs);

      // scoreTimeDiv.appendChild(createScoreTimeSVG(bb.width, 200));
      const serializer = new XMLSerializer();
      // console.info('stSVG: ' + stSVG);
      let scoreTimeDiv = document.getElementById("performanceTime");
      scoreTimeDiv.innerHTML = serializer.serializeToString(ptObj);
      if (pieceSel && pieceSel.value && perfSel && perfSel.value)
        scoreTimeDiv.innerHTML += "<p><b>" + perfSel.value + "</b></p>";

      drawConnectorLines('score');
      drawTimeAxis(document.querySelector('.performanceTime'));

      // DEBUG: plot warping function...
      // let pageMarginElement = document.querySelector('.page-margin');
      // drawWarpFunction(pageMarginElement,
      //   createWarpingFunction(noteSVGXs, svgViewBox));

      // createSVGDownloadLink(serializer.serializeToString(svgObj));
      // drawPerformanceLinesInSvg();
    }

    function getFirstOnsetIdx(maps) {
      let i = 0;
      while (maps[i].obs_mean_onset < 0) i++;
      // console.info('getFirstOnsetIdx i: ' + i);
      return i;
    }

    function getLastOnsetIdx(maps) {
      let i = maps.length - 1;
      while (maps[i].xml_id[0].includes('trompa')) i--;
      // console.info('getLastOnsetIdx i: ' + i);
      return i;
    }

    // Returns x value in pure SVG coordinates of SVG element ()
    function getX(el) {
      switch (el.nodeName) {
        case 'polygon':
          return el.points.getItem(0).x;
        case 'path':
          return el.pathSegList.getItem(0).x;
        case 'ellipse' || 'circle':
          return parseFloat(el.getAttribute('cx'));
        case 'rect' || 'use' || 'text':
          return parseFloat(el.getAttribute('x'));
        case 'g': // for .chord, .note
          let className = el.getAttribute('class');
          if (className && (className == 'chord' || className == 'note'))
            return parseFloat(
              el.querySelector('.notehead>use[x]').getAttribute('x'));
          else
            return parseFloat(el.querySelector('use[x]').getAttribute('x'));
      }
    }

    // shift elements horizontally by modifying all x coordinates using
    // the delta warpingFunction
    function shiftElements(elementList, delta) {
      elementList.forEach(item => {
        // console.info('Shifting ', item);
        if (item.nodeName == 'polygon') { // beam,
          let pointsList = item.points;
          let n = pointsList.numberOfItems;
          let beam = item.closest('.beam');
          if (beam && n == 4) {
            shiftBeam(beam, item, delta);
          } else {
            // console.info('ShiftPolygon ', item);
            // console.info('with ' + n + ' points: ', item.points);
            for (let m = 0; m < n; m++) {
              var mySVGPoint = svgObj.createSVGPoint();
              let x = pointsList.getItem(m).x;
              mySVGPoint.x = x + delta[Math.round(x)];
              mySVGPoint.y = pointsList.getItem(m).y;
              pointsList.replaceItem(mySVGPoint, m);
            }
          }
        } else if (item.nodeName == 'path') {
          let segList = item.pathSegList;
          let n = segList.numberOfItems;
          let ledgerLines = item.closest('.ledgerLines');
          if (ledgerLines && n == 2) { // first 1/8x to translate ledgerLines
            // console.info('shiftElements ledgerLines: ', ledgerLines);
            let x = Math.round((segList[0].x * 7 + segList[1].x) / 8);
            translate(item, delta[x]);
          } else {
            for (let i = 0; i < n; i++) {
              var segment = segList.getItem(i);
              segment.x += delta[Math.round(Math.max(0, segment.x))];
              if (segment.x1)
                segment.x1 += delta[Math.round(Math.max(0, segment.x1))];
              if (segment.x2)
                segment.x2 += delta[Math.round(Math.max(0, segment.x2))];
            }
          }
        } else if (item.nodeName == 'g') { // note / chord / arpeg
          let x = getX(item);
          let d = delta[Math.round(x)];
          if (item.className.baseVal == "arpeg") {
            console.info('shiftElements ARPEG: ', item);
            addTranslation(item, d);
          } else {
            translate(item, d); // translate in combination w\ existing translte
            // if within chord & first note in chord, translate stem/artic too
            let chord = item.closest('.chord');
            if (chord && chord.querySelector('.note').getAttribute('id') ==
              item.getAttribute('id')) {
              translate(chord.querySelector('.stem'), d);
              let artics = chord.querySelectorAll('.artic');
              if (artics) artics.forEach(item => translate(item, d));
              let dots = chord.querySelectorAll('.dots');
              if (dots) dots.forEach(item => translate(item, d));
            }
          }
          // console.info('transform on ', item);
        } else { // rect, use, text, ellipse, circle
          if (!item.closest('.chord') && !item.closest('.note')) { // not within
            let attribute = 'x';
            if (item.nodeName == 'ellipse' || item.nodeName == 'circle')
              attribute = 'cx';
            let x = parseFloat(item.getAttribute(attribute));
            let d = 0;
            d = delta[Math.round(x)];
            item.setAttribute(attribute, x + d);
          }
        }
      });
    }

    function adjustIndividualNotes() {
      maps.forEach((item, i) => {
        if (i >= getFirstOnsetIdx(maps) && i <= getLastOnsetIdx(maps)) {
          let onsetSVGx = time2svg(item.obs_mean_onset);
          item.xml_id.forEach(id => {
            let note = svgObj.querySelector(`[*|id="${id}"]`);
            if (note) {
              let use = note.querySelector('g.notehead use');
              let noteX = parseFloat(use.getAttribute('x'));
              translate(note, onsetSVGx - noteX, false);
            }
          });
        }
      });
    }

    function createWarpingFunction(noteSVGXs, svgViewBox) {
      let width = svgViewBox[2] - svgViewBox[0];
      // console.info('onsetSVGXs, ', onsetSVGXs);
      // console.info('noteSVGXs, ', noteSVGXs);
      // console.info('noteXs, ', noteXs);
      // console.info('svgViewBox, ', svgViewBox);
      // console.info('warpFunc width: ', width);
      let warpFunc = [];
      let [j, x0, v1, v2, ip, lastIp] = [0, 0, 0, 0, 0, 0];
      for (let x = 0; x < width; x++) {
        if (noteSVGXs[j] <= x) {
          x0 = x;
          j++;
        }
        if (j <= 0 || j >= width) ip = lastIp;
        else {
          v1 = onsetSVGXs[j - 1] - noteSVGXs[j - 1]; // onset minus note
          v2 = onsetSVGXs[Math.min(j, onsetSVGXs.length - 1)] -
            noteSVGXs[Math.min(j, noteSVGXs.length - 1)];
          ip = lerp(v1, v2, (x - x0) / (noteSVGXs[j] - noteSVGXs[j - 1]));
          if (!ip) ip = lastIp;
        }
        warpFunc.push(ip);
        lastIp = ip;
        // console.info('x: ', x + ', j:' + j + ', ' + v1 + '/' + v2 + ', ip:' + ip);
      };
      return warpFunc;
    }

    function lerp(v0, v1, t) { // linear interpolation; t from 0 to lgt - 1
      return (1 - t) * v0 + t * v1;
    }

    // translate item object, checking if a translate is already there.
    function translate(item, delta, useExisting = true) {
      let existingX = 0;
      let trList = item.transform.baseVal; // SVGTransformList
      if (trList && trList.length > 0) { // if transform exists
        console.info('SVGTransformList EXISTING: ', trList);
        let index = -1;
        for (currTrans of trList) {
          index++;
          // trList.forEach((currTrans, i) => {
          if (currTrans.type == SVGTransform.SVG_TRANSFORM_TRANSLATE) {
            console.info('TRANSLATION FOUND: ', item);
            if (useExisting) existingX = currTrans.matrix.e;
            break;
          }
        }
        trList.getItem(index).setTranslate(existingX + delta, 0);
      } else { // create new transform
        // console.info('SVGTransformList EMPTY: ', trList);
        // if (useExisting) {
        //   existingX = trList.getItem(0).matrix.e;
        //   if (existingX > 0) console.info('EXISTING X: ' + existingX, item);
        // }
        let translate = svgObj.createSVGTransform();
        translate.setTranslate(existingX + delta, 0);
        item.transform.baseVal.appendItem(translate);
      }
    }

    function addTranslation(item, delta) {
      let newTranslate = svgObj.createSVGTransform();
      newTranslate.setTranslate(delta, 0);
      item.transform.baseVal.insertItemBefore(newTranslate, 0);
    }

    function shiftBeam(beam, polygon, delta) {
      let stems = beam.querySelectorAll('.stem > rect');
      let px1 = polygon.points[0].x;
      let px2 = polygon.points[1].x;
      // console.info('beam: ', beam);
      // console.info('shiftBeam px12: ' + px1 + '/' + px2 + ', ', stems);
      let diffs1 = [];
      let diffs2 = [];
      stems.forEach((item) => {
        diffs1.push(Math.abs(item.getAttribute('x') - px1));
        diffs2.push(Math.abs(item.getAttribute('x') - px2));
      });
      // console.info('diffs: ', diffs1, diffs2);
      let i1 = indexOfMin(diffs1);
      let i2 = indexOfMin(diffs2);
      if (stems[i1].getAttribute('id') == stems[i2].getAttribute('x')) {
        if (diffs1(i1) <= diff2(i2))
          i2 = indexOfMin(diffs2, i2);
        else
          i1 = indexOfMin(diffs1, i1);
      }
      let n1 = stems[i1].closest('.note');
      if (!n1) n1 = stems[i1].closest('.chord');
      x1 = n1.querySelector('.notehead>use').getAttribute('x');
      let n2 = stems[i2].closest('.note');
      if (!n2) n2 = stems[i2].closest('.chord');
      x2 = n2.querySelector('.notehead>use').getAttribute('x');

      for (let m = 0; m < polygon.points.numberOfItems; m++) {
        var mySVGPoint = svgObj.createSVGPoint();
        let x = polygon.points.getItem(m).x;
        if (m == 0 || m == 3)
          mySVGPoint.x = x + delta[Math.round(x1)];
        else
          mySVGPoint.x = x + delta[Math.round(x2)];
        mySVGPoint.y = polygon.points.getItem(m).y;
        polygon.points.replaceItem(mySVGPoint, m);
      }
    }

    // Create SVG for score time plotting
    function createScoreTimeSVG(width, height, ) {
      const stSVG = document.createElementNS(svgNS, 'svg');
      stSVG.setAttribute('width', width);
      stSVG.setAttribute('height', height);
      return stSVG;
    }

    function addLine(node, x1, x2, y1, y2, color = "black", strokeWidth = 1) {
      const line = document.createElementNS(svgNS, 'line');
      line.setAttribute('x1', x1);
      line.setAttribute('x2', x2);
      line.setAttribute('y1', y1);
      line.setAttribute('y2', y2);
      line.setAttribute('stroke-width', strokeWidth);
      line.setAttribute('stroke-linecap', 'round');
      line.setAttribute('stroke', color);
      return node.appendChild(line);
    }

    function addCircle(node, cx, cy, r, color = "black", strokeWidth = 1) {
      const circle = document.createElementNS(svgNS, 'circle');
      circle.setAttribute('cx', cx);
      circle.setAttribute('cy', cy);
      circle.setAttribute('r', r);
      circle.setAttribute('stroke-width', strokeWidth);
      circle.setAttribute('stroke', color);
      return node.appendChild(circle);
    }

    function addText(node, text, x, y, halign = "middle", color = "black") {
      let txt = document.createElementNS(svgNS, 'text');
      txt.setAttribute('text-anchor', halign);
      txt.setAttribute('font-family', 'Arial, Helvetica, sans-serif');
      txt.setAttribute('font-size', 10.5);
      txt.setAttribute('fill', color);
      txt.setAttribute('x', x);
      txt.setAttribute('y', y);
      txt.appendChild(document.createTextNode(text));
      return node.appendChild(txt);
    }

    function drawTimeAxis(node, toScreen = true, y = y0basis, color = "black") {
      const g = document.createElementNS(svgNS, 'g'); // time axis in notation
      g.setAttribute('class', 'timeAxis');
      node.appendChild(g);
      let incr = 10; // seconds
      let lastTick = Math.ceil(tmx / incr) * incr;
      let s, s2;
      for (let t = 0; t <= lastTick; t += incr) {
        (toScreen) ? s = time2screen(t): s = time2svg(t);
        addLine(g, s, s, y, y + 2, color, 1);
        addText(g, t, s, y + 12, 'middle', color);
        if (t == 0) {
          (toScreen) ? s2 = time2screen(lastTick): time2svg(lastTick);
          addLine(g, s, s2, y, y, color, 1);
          addText(g, 'Time (s)', 1, y - 4, "left", color);
        }
      }
    }

    // convert time in seconds to screen coordinate x values
    function time2screen(t) {
      return (t - tmn) / (tmx - tmn) * (lstX - fstX) + fstX;
    }

    // convert time in seconds to svg x coordinates inside pageMargin
    function time2svg(t) {
      return (t - tmn) / (tmx - tmn) *
        (noteSVGXs[noteSVGXs.length - 1] - noteSVGXs[0]) + noteSVGXs[0];
    }

    // convert svg x coordinates inside pageMargin to screen coordinates
    function svg2screen(x, pageMarginX) {
      return (x + pgMarginX) * svgWidth / (svgViewBox[2] - svgViewBox[0]);
    }

    function indexOfMin(a, notThis = -1) {
      let lowest = 0;
      a.forEach((item, i) => {
        if (item < a[lowest] && i != notThis) lowest = i;
      });
      return lowest;
    }

    function updateMeiFile(fileName = "") {
      meiFileName = fileName;
      console.info("updateMEIfile " + meiFileName);
      clearAllLines();
      loadMEI();
    }

    function updateMapsFile(fileName = "") {
      mapsFileName = fileName;
      console.info("updateMapsFile " + mapsFileName);
      clearAllLines();
      if (warped) loadMEI(false);
      fetch(mapsFileName)
        .then(response => response.json())
        .then(json => {
          maps = json;
          loadPerformanceTiming(maps);
        });
      console.info('updateMapsFile maps: ', maps);
    }

    window.onload = function() {
      pieceSel = document.getElementById("piece");
      perfSel = document.getElementById("performance");
      let pieceName;
      let pieceFile;
      for (var x in demoFiles) {
        pieceSel.options[pieceSel.options.length] = new Option(x, x);
      }
      pieceSel.onchange = function() {
        perfSel.length = 1; // to clear existing menu entries
        pieceName = this.value;
        pieceFile = demoFiles[this.value].meiFile;
        console.info('this.value: ' + this.value + ', pieceName: ' + pieceName);
        for (var y in demoFiles[this.value].performances) {
          perfSel.options[perfSel.options.length] = new Option(y, y);
        }
        updateMeiFile(pieceFile);
      }
      perfSel.onchange = function() {
        let performanceName = this.value;
        let mapsFile = demoFiles[pieceSel.value].performances[this.value];
        console.info("Performance: " + performanceName + ', mapsFile:' + mapsFile);
        updateMapsFile(mapsFile);
      }
    }

    // creates a downloadable file with svg as text, and a download link
    function createSVGDownloadLink() {
      if (svgObj) {
        let svg = new XMLSerializer().serializeToString(svgObj);
        let type = "image/svg+xml";
        let a = document.getElementById("downloadLink");
        var file = new Blob([svg], {
          type: type
        });
        a.href = URL.createObjectURL(file);
        let svgName = "";
        if (!warped && pieceSel && pieceSel.value) {
          svgName = pieceSel.value;
          a.innerHTML = "Download SVG";
        }
        if (warped && pieceSel && pieceSel.value && perfSel && perfSel.value) {
          svgName = pieceSel.value + '_' + perfSel.value;
          a.innerHTML = "Download Warped SVG";
        }
        a.download = svgName;
      }
    }
    //
  </script>
</head>

<body style="font-family:Arial, Helvetica, sans-serif">
  <h1>Let&rsquo;s do the SVG Warp again!</h1>
  <p>
  <form name="form1" id="form1" action="#">
    Demo pieces/performances <select name="piece" id="piece">
      <option value="" selected="selected">Select a piece</option>
    </select>
    <select name="performance" id="performance">
      <option value="" selected="selected">Select a performance</option>
    </select>
    <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</b>
  </form>
  <button onclick="warp()">1) Warp [W]</button>
  <button onclick="warpNotes()">2) Warp notes inside chords [A]</button>
  <button onclick="loadMEI(false)">3) Reload data [C]</button>
  <button onclick="createSVGDownloadLink()">4) Create SVG Download [D]</button>
  <a href id="downloadLink"></a>
  </p>
  <div id="notation">
    <p><b>Please load an MEI score file.</b></p>
  </div>
  <div id="performanceTime"></div>
  <p id="copyright" style="font-size:xx-small;">
    <a href="https://iwk.mdw.ac.at/goebl/">Werner Goebl</a>, 26 October 2021.
  </p>
</body>

</html>
